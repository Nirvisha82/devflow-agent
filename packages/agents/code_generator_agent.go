package agents

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"strings"

	"devflow-agent/packages/config"

	"google.golang.org/genai"
)

// CodeGeneratorAgent generates code modifications based on the issue and current code
type CodeGeneratorAgent struct {
	codeFilesContent string
	issueTitle       string
	issueBody        string
	repoPath         string
}

// CodeGeneratorResult contains the generated code modifications
type CodeGeneratorResult struct {
	Modifications map[string]string // filepath -> new content
	Summary       string
}

// NewCodeGeneratorAgent creates a new code generator agent
func NewCodeGeneratorAgent(codeFilesContent, issueTitle, issueBody, repoPath string) *CodeGeneratorAgent {
	return &CodeGeneratorAgent{
		codeFilesContent: codeFilesContent,
		issueTitle:       issueTitle,
		issueBody:        issueBody,
		repoPath:         repoPath,
	}
}

// Generate creates the code modifications
func (c *CodeGeneratorAgent) Generate() (*CodeGeneratorResult, error) {
	slog.Info("CodeGenerator: Starting code generation")

	// Use AI to generate code modifications
	modifications, summary, err := c.generateWithAI()
	if err != nil {
		return nil, fmt.Errorf("AI code generation failed: %w", err)
	}

	slog.Info("CodeGenerator: Generation complete", "files", len(modifications))

	return &CodeGeneratorResult{
		Modifications: modifications,
		Summary:       summary,
	}, nil
}

// generateWithAI uses Gemini to generate code modifications
func (c *CodeGeneratorAgent) generateWithAI() (map[string]string, string, error) {
	slog.Info("CodeGenerator: Generating with AI")

	prompt := fmt.Sprintf(`You are a Code Generator Agent in the Devflow system. Your task is to generate the exact code modifications needed to resolve the given issue.

# Issue Information
**Title:** %s

**Description:**
%s

# Current Code Files
%s

# Your Task
Generate the complete, modified content for each file that needs changes. Be specific and provide the full file content after modifications.

Respond in JSON format:
{
  "modifications": {
    "path/to/file1.go": "complete new file content here",
    "path/to/file2.go": "complete new file content here"
  },
  "summary": "Brief summary of changes made"
}

IMPORTANT:
- Provide COMPLETE file contents, not just diffs
- Ensure all syntax is correct for the language
- Maintain existing code style and conventions
- Add appropriate comments for new code
- Consider error handling and edge cases
- Only modify files that actually need changes
- Keep imports and package declarations intact`,
		c.issueTitle,
		c.issueBody,
		c.codeFilesContent,
	)

	// Call Gemini API
	result, err := c.callGeminiAPI(prompt)
	if err != nil {
		return nil, "", err
	}

	// Parse JSON response
	var response struct {
		Modifications map[string]string `json:"modifications"`
		Summary       string            `json:"summary"`
	}

	// Clean up the response (remove markdown code blocks if present)
	result = strings.TrimSpace(result)
	if strings.HasPrefix(result, "```json") {
		result = strings.TrimPrefix(result, "```json")
		result = strings.TrimSuffix(result, "```")
		result = strings.TrimSpace(result)
	} else if strings.HasPrefix(result, "```") {
		result = strings.TrimPrefix(result, "```")
		result = strings.TrimSuffix(result, "```")
		result = strings.TrimSpace(result)
	}

	err = json.Unmarshal([]byte(result), &response)
	if err != nil {
		return nil, "", fmt.Errorf("failed to parse AI response: %w\nResponse: %s", err, result[:min(len(result), 500)])
	}

	if len(response.Modifications) == 0 {
		return nil, "", fmt.Errorf("no modifications generated by AI")
	}

	return response.Modifications, response.Summary, nil
}

// callGeminiAPI calls the new Gemini API
func (c *CodeGeneratorAgent) callGeminiAPI(prompt string) (string, error) {
	apiKey := os.Getenv("GEMINI_API_KEY")
	if apiKey == "" {
		return "", fmt.Errorf("GEMINI_API_KEY not set in environment")
	}

	ctx := context.Background()

	// Create client using new SDK
	client, err := genai.NewClient(ctx, &genai.ClientConfig{
		APIKey:  apiKey,
		Backend: genai.BackendGeminiAPI,
	})
	if err != nil {
		return "", fmt.Errorf("failed to create Gemini client: %w", err)
	}
	// Note: No Close() method in new SDK - client manages lifecycle automatically

	cfg := config.GetConfig()

	// Use lower temperature for more deterministic code generation
	// Use float64 and int types directly (not float32/int32)
	temperature := float32(0.3)
	topK := float32(cfg.AI.TopK)
	topP := float32(cfg.AI.TopP)
	maxTokens := int32(cfg.AI.MaxOutputTokens)

	genConfig := &genai.GenerateContentConfig{
		Temperature:     &temperature,
		TopK:            &topK,
		TopP:            &topP,
		MaxOutputTokens: maxTokens,
	}

	slog.Info("CodeGenerator: Calling Gemini API")

	// Generate content using new API
	result, err := client.Models.GenerateContent(
		ctx,
		cfg.AI.Model,
		genai.Text(prompt),
		genConfig,
	)
	if err != nil {
		return "", fmt.Errorf("gemini API call failed: %w", err)
	}

	// Extract text from response
	if result == nil || result.Text() == "" {
		return "", fmt.Errorf("no content generated by Gemini")
	}

	responseText := result.Text()
	slog.Info("CodeGenerator: Received response from Gemini", "length", len(responseText))

	return responseText, nil
}

// Helper function for min
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
