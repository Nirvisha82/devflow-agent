import os
from strands_tools import file_read, file_write, editor
from strands import tool

@tool
def load_repo_analysis(repo_path: str) -> str:
    """Load repository analysis from .devflow directory."""
    print(f"[Tool] load_repo_analysis: Loading from {repo_path}")
    
    # Convert to absolute path if relative
    if not os.path.isabs(repo_path):
        repo_path = os.path.abspath(repo_path)
        print(f"[Tool] Converted to absolute path: {repo_path}")
    
    analysis_file = os.path.join(repo_path, ".devflow", "repo-analysis.md")
    print(f"[Tool] Looking for analysis at: {analysis_file}")
    
    if os.path.exists(analysis_file):
        with open(analysis_file, 'r') as f:
            content = f.read()
            print(f"[Tool] Loaded analysis file ({len(content)} chars)")
            return content
    print(f"[Tool] Analysis file not found at {analysis_file}")
    return "No repo analysis available"

@tool
def load_dependency_graph(repo_path: str) -> str:
    """Load dependency graph from .devflow directory."""
    print(f"[Tool] load_dependency_graph: Loading from {repo_path}")
    
    # Convert to absolute path if relative
    if not os.path.isabs(repo_path):
        repo_path = os.path.abspath(repo_path)
    
    dep_file = os.path.join(repo_path, ".devflow", "dependency-graph.json")
    print(f"[Tool] Looking for dependency graph at: {dep_file}")
    
    if os.path.exists(dep_file):
        with open(dep_file, 'r') as f:
            content = f.read()
            print(f"[Tool] Loaded dependency graph ({len(content)} chars)")
            return content
    print(f"[Tool] Dependency graph not found at {dep_file}")
    return "No dependency graph available"

@tool
def list_files(repo_path: str) -> str:
    """List all files in the repository."""
    print(f"[Tool] list_files: Listing files in {repo_path}")
    
    # Convert to absolute path if relative
    if not os.path.isabs(repo_path):
        repo_path = os.path.abspath(repo_path)
    
    if not os.path.exists(repo_path):
        return f"Error: Directory does not exist: {repo_path}"
    
    files = []
    ignore_patterns = ['.git', 'node_modules', '__pycache__', '.venv', 'venv', 'dist', 'build', '.devflow']
    
    for root, _, filenames in os.walk(repo_path):
        if any(pattern in root for pattern in ignore_patterns):
            continue
        for filename in filenames:
            abs_path = os.path.join(root, filename)
            rel_path = os.path.relpath(abs_path, repo_path)
            files.append(rel_path)
    
    result = "\n".join(files[:100])
    print(f"[Tool] Found {len(files)} files (showing first 100)")
    return result

@tool
def generate_pr_body_tool(output_path: str, issue_title: str, summary: str, 
                          files_modified: str, technical_details: str = "",
                          testing_instructions: str = "", additional_notes: str = "") -> str:
    """
    Generate PR body and save to markdown file.
    
    Args:
        output_path: Where to save the generated PR body
        issue_title: Title of the issue being fixed
        summary: Brief summary of changes
        files_modified: List of files that were modified
        technical_details: Technical implementation details
        testing_instructions: How to test the changes
        additional_notes: Any additional notes
    
    Returns:
        Success message with output path
    """
    print(f"[Tool] generate_pr_body_tool: Creating PR body at {output_path}")
    
    try:
        # Convert to absolute path if relative
        if not os.path.isabs(output_path):
            output_path = os.path.abspath(output_path)
        
        # Create PR body content
        pr_body = f"""# ðŸ”§ Fix: {issue_title}

## Overview
{summary}

## ðŸ“ Changes Made

### Files Modified
{files_modified}

## ðŸ”§ Technical Implementation
{technical_details if technical_details else "See code changes for implementation details."}

## ðŸ§ª Testing Instructions
{testing_instructions if testing_instructions else "1. Review the code changes\n2. Run existing tests\n3. Verify the changes work as expected"}

## ðŸ“‹ Additional Notes
{additional_notes if additional_notes else "No additional notes."}

---
*This PR was automatically generated by DevFlow Agent*
"""
        
        # Ensure output directory exists
        output_dir = os.path.dirname(output_path)
        if output_dir:
            os.makedirs(output_dir, exist_ok=True)
        
        # Save to output
        with open(output_path, 'w') as f:
            f.write(pr_body)
        
        print(f"[Tool] PR body successfully generated ({len(pr_body)} chars)")
        return f"PR body successfully generated at: {output_path}"
    except Exception as e:
        error_msg = f"Error generating PR body: {str(e)}"
        print(f"[Tool] {error_msg}")
        return error_msg


# Custom tool wrappers with logging and absolute path handling
@tool
def logged_file_read(path: str) -> str:
    """Read file with logging and absolute path handling."""
    # Convert to absolute path if relative
    if not os.path.isabs(path):
        path = os.path.abspath(path)
    
    print(f"[Tool] file_read: Reading {path}")
    
    if not os.path.exists(path):
        error_msg = f"Error: File does not exist: {path}"
        print(f"[Tool] {error_msg}")
        return error_msg
    
    return file_read(path)

@tool
def logged_file_write(path: str, content: str) -> str:
    """Write file with logging and absolute path handling."""
    # Convert to absolute path if relative
    if not os.path.isabs(path):
        path = os.path.abspath(path)
    
    print(f"[Tool] file_write: Writing to {path} ({len(content)} chars)")
    return file_write(path, content)

@tool
def logged_editor(path: str, old_str: str, new_str: str) -> str:
    """Edit file with logging and absolute path handling."""
    # Convert to absolute path if relative
    if not os.path.isabs(path):
        path = os.path.abspath(path)
    
    print(f"[Tool] editor: Editing {path} (replacing {len(old_str)} chars with {len(new_str)} chars)")
    
    if not os.path.exists(path):
        error_msg = f"Error: File does not exist: {path}"
        print(f"[Tool] {error_msg}")
        return error_msg
    
    return editor(path, old_str, new_str)